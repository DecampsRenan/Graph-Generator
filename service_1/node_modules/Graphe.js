// Classe utilitaire pour les graphes
var Graph = require('graph').Graph;

/**
 * Classe générant un objet graphe à partir
 * du fichier passé en paramètre.
 **/
var Graphe = function(nbNodes, density) {

	// Structure de données contenant l'arbre
	this.g = {
		nodes : [
		],
		edges : [
		],
		density: density
	};

	/*
		* stackoverflow.com/questions/2041517/random-simple-connected-graph-generation-with-given-sparseness *
		For each node you need at least one edge.

		Start with one node. In each iteration, create a new node and a new
		edge. The edge is to connect the new node with a random node
		from the previous node set.

		After all nodes are created, create random edges until S is fulfilled.
		Make sure not to create double edges (for this you can use an
		adjacency matrix).

		Random graph is done in O(S).
	*/

	// On génère les neuds
	for (var i = 0; i < nbNodes; i++) {
		this.g.nodes[i] = {
			data: {
				id: '' + i
			}
		};
	}

	// On les parcours afin de les lier
	for (var i = 0; i < this.g.nodes.length; i++) {
		console.log(this.g.nodes[i]);
	};
};

Graphe.prototype = {

	toString: function() {
		return this.g.toString();
	},

	toJSON: function() {

		return {
			nodes: [
				{ data: { id: 'a' } },
				{ data: { id: 'b' } },
				{ data: { id: 'c' } },
				{ data: { id: 'd' } },
				{ data: { id: 'e' } }
			],

			edges: [
				{ data: { id: 'ae', weight: 1, source: 'a', target: 'e' } },
				{ data: { id: 'ab', weight: 3, source: 'a', target: 'b' } },
				{ data: { id: 'be', weight: 4, source: 'b', target: 'e' } },
				{ data: { id: 'bc', weight: 5, source: 'b', target: 'c' } },
				{ data: { id: 'ce', weight: 6, source: 'c', target: 'e' } },
				{ data: { id: 'cd', weight: 2, source: 'c', target: 'd' } },
				{ data: { id: 'de', weight: 7, source: 'd', target: 'e' } }
			]
		};
	}
};

module.exports = Graphe;
