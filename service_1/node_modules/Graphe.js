/**
 * Classe générant un objet graphe à partir
 * du fichier passé en paramètre.
 **/
var Graphe = function(nbNodes, density) {

	// Structure de données contenant l'arbre
	this.g = { nodes : [], edges : [] };

	// Contient les ensembles de noeuds déjà utilisés;
	var used = [];

	// Générer un nombre d'arêtes aléatoire (entre nbNodes - 1 et MAX noeuds);
	var nbEdgesMax = (nbNodes*(nbNodes-1))/2;
	var nbEdgesMin = nbNodes - 1;

	console.log(nbEdgesMax, '-', nbEdgesMin, '=', nbEdgesMax-nbEdgesMin);

	// A changer par la densité.
	var nbEdges = randomInt(nbEdgesMin, nbEdgesMax+1);
	var nbEdgesRestants = nbEdges;
	// On crée les noeuds
	for(var i = 1; i <= nbNodes; i++) {
		this.g.nodes.push({data: {id: '' + i, nbEdges: 0}});
	}
	
	// On lit les noeuds tant que l'on a pas atteint le quota.
	while(nbEdgesRestants > 0) {

		// On choisi 2 noeuds quelconques (entre 0 et this.g.nodes.length);
		var a = 0;
		var b = a;
		
		// On boucle tant que la paire de sommets générée est identique,
		// ou tant que les sommets générés ne font pas partis de ceux
		// déjà utilisés.
		var isDone = false;
		while(!isDone) {
			a = randomInt(1, this.g.nodes.length+1);
			b = randomInt(1, this.g.nodes.length+1);

			if (a != b) {
				var cantBeLinked = used.some(function(currentValue, index, arr) {
					if (currentValue === (a + '' + b) || currentValue === (b + '' + a)) return true;
				});
				if (!cantBeLinked) {
					isDone = true;
				}
			}
		}

		// Construction de l'arête
		var edge = {
			data: {
				id: a + '' + b,
				weight: randomInt(1, 20),
				source: '' + a,
				target: '' + b
			}
		};

		// Ajout de la paire de sommets dans ceux
		// qui sont déjà utilisés
		used.push(edge.data.id);

		// Ajout de l'arête au graphe
		this.g.edges.push(edge);

		// M.A.J
		this.majNbEdges();
		console.log(this.g.nodes);
		nbEdgesRestants--;
	}
};

// Définition des méthodes de classe
Graphe.prototype = {

	// Retourne une chaine de caractères
	// décrivant le graphe
	toString: function() {
		return this.g.toString();
	},

	// Retourne le graphe sous forme d'objet
	toJSON: function() {
		return this.g;
	},

	// Mise à jour du nombre d'arêtes associées
	// à un noeud
	majNbEdges: function() {
		this.g.nodes.forEach(function(value, i, arr) {
			var currentNode = value.data.id;

			nbEdges = this.g.edges.reduce(function(previousVal, currentVal, index, arr) {
				if (currentVal.data.id.indexOf(currentNode) != -1) {
					return previousVal + 1;
				} else {
					return previousVal;
				}
			}, 0);

			value.nbEdges = nbEdges;
		}, this);
	}
};

// Génère un nombre aléatoire en min (inclu) et max (exclu)
function randomInt(min, max) {
	return Math.floor(Math.random() * (max - min)) + min;
}

module.exports = Graphe;
